/**
 * Escape HTML special characters to prevent injection in exported documents.
 */
function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/**
 * Converts markdown content to a basic HTML string for doc/pdf export.
 * Handles: headers, bold, italic, tables, lists, horizontal rules, paragraphs.
 */
function markdownToHtml(md: string): string {
  let html = md;

  // Escape HTML entities (except our markdown chars)
  html = html.replace(/&/g, '&amp;');
  html = html.replace(/</g, '&lt;');
  html = html.replace(/>/g, '&gt;');

  // Blockquotes — process AFTER escaping, matching the escaped ">" character
  html = html.replace(/^&gt; (.+)$/gm, '<blockquote style="border-left:4px solid #93c5fd;background:#eff6ff;padding:8px 16px;margin:12px 0;border-radius:0 8px 8px 0;font-style:italic;font-size:14px;color:#334155;">$1</blockquote>');

  // Tables — process before other rules
  html = html.replace(/^(\|.+\|)\n(\|[\s\-:|]+\|)\n((?:\|.+\|\n?)+)/gm, (_match, headerRow: string, _sepRow: string, bodyRows: string) => {
    const headers = headerRow.split('|').filter((c: string) => c.trim()).map((c: string) => `<th style="border:1px solid #ddd;padding:8px 12px;background:#f8fafc;text-align:left;font-size:13px;">${c.trim()}</th>`);
    const rows = bodyRows.trim().split('\n').map((row: string) => {
      const cells = row.split('|').filter((c: string) => c.trim()).map((c: string) => `<td style="border:1px solid #ddd;padding:8px 12px;font-size:13px;">${c.trim()}</td>`);
      return `<tr>${cells.join('')}</tr>`;
    });
    return `<table style="border-collapse:collapse;width:100%;margin:16px 0;"><thead><tr>${headers.join('')}</tr></thead><tbody>${rows.join('')}</tbody></table>`;
  });

  // Headers
  html = html.replace(/^### (.+)$/gm, '<h3 style="margin:20px 0 8px;font-size:16px;color:#1e293b;">$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2 style="margin:24px 0 10px;font-size:20px;color:#1e293b;">$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1 style="margin:28px 0 12px;font-size:24px;color:#0f172a;">$1</h1>');

  // Horizontal rules
  html = html.replace(/^---+$/gm, '<hr style="border:none;border-top:1px solid #e2e8f0;margin:20px 0;">');

  // Bold and italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // Unordered lists
  html = html.replace(/^(\s*)[-*] (.+)$/gm, '$1<li style="margin:4px 0;font-size:14px;">$2</li>');
  html = html.replace(/((?:<li[^>]*>.*<\/li>\n?)+)/g, '<ul style="margin:8px 0;padding-left:24px;">$1</ul>');

  // Ordered lists — wrap consecutive <li> items from numbered patterns in <ol>
  html = html.replace(/^\d+\. (.+)$/gm, '<oli style="margin:4px 0;font-size:14px;">$1</oli>');
  html = html.replace(/((?:<oli[^>]*>.*<\/oli>\n?)+)/g, (_match, items: string) => {
    const fixed = items.replace(/<oli/g, '<li').replace(/<\/oli>/g, '</li>');
    return `<ol style="margin:8px 0;padding-left:24px;">${fixed}</ol>`;
  });

  // Paragraphs — wrap remaining text lines
  html = html.replace(/^(?!<[a-z])((?!<\/|<ul|<ol|<li|<h[1-3]|<hr|<table|<thead|<tbody|<tr|<td|<th).+)$/gm, '<p style="margin:8px 0;font-size:14px;line-height:1.6;color:#334155;">$1</p>');

  // Clean up empty paragraphs
  html = html.replace(/<p[^>]*>\s*<\/p>/g, '');

  return html;
}

function buildHtmlDocument(content: string, title: string): string {
  const safeTitle = escapeHtml(title);
  const bodyHtml = markdownToHtml(content);
  return `<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>${safeTitle}</title>
<style>
  @page { margin: 1in; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 40px;
    color: #1e293b;
    line-height: 1.6;
  }
  table { page-break-inside: avoid; }
  h1, h2, h3 { page-break-after: avoid; }
</style>
</head>
<body>
<h1 style="font-size:28px;color:#0f172a;border-bottom:2px solid #e2e8f0;padding-bottom:12px;margin-bottom:24px;">${safeTitle}</h1>
${bodyHtml}
<p style="margin-top:40px;font-size:11px;color:#94a3b8;border-top:1px solid #e2e8f0;padding-top:12px;">Generated by Viasox Marketing Intelligence</p>
</body>
</html>`;
}

/**
 * Download content as a .doc file (HTML-based, opens in Word/Google Docs)
 */
export function downloadAsDoc(content: string, title: string): void {
  const html = buildHtmlDocument(content, title);
  const blob = new Blob([html], { type: 'application/msword' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${title.toLowerCase().replace(/\s+/g, '-')}.doc`;
  a.click();
  URL.revokeObjectURL(url);
}

/**
 * Download content as PDF using a print-to-PDF approach
 */
export function downloadAsPdf(content: string, title: string): void {
  const html = buildHtmlDocument(content, title);
  const printWindow = window.open('', '_blank');
  if (!printWindow) {
    // Fallback: if popup blocked, download as HTML with .pdf suggestion
    alert('Pop-up blocked. Please allow pop-ups to generate PDF, or use the .doc download option.');
    return;
  }
  printWindow.document.write(html);
  printWindow.document.close();

  // Use a flag to prevent double print() invocation
  let printed = false;
  const triggerPrint = () => {
    if (printed) return;
    printed = true;
    printWindow.print();
  };

  // Wait for content to render, then trigger print (Save as PDF)
  printWindow.onload = triggerPrint;
  // Fallback for browsers where onload doesn't fire on document.write
  setTimeout(triggerPrint, 500);
}
